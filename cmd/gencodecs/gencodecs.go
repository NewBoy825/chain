// gencodecs - generate codecs for the protocol/bc data types

package main

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"chain/protocol/bc"
)

// type (
// 	foo [2]uint8
// 	bar []foo
// 	baz struct {
// 		a, b uint32
// 		c []byte `bc:"extstr=1"`
// 	}
// )

var types = []reflect.Type{
	reflect.TypeOf((*bc.Block)(nil)).Elem(),
	reflect.TypeOf((*bc.BlockHeader)(nil)).Elem(),
	reflect.TypeOf((*bc.Tx)(nil)).Elem(),
	reflect.TypeOf((*bc.TxData)(nil)).Elem(),
	reflect.TypeOf((*bc.TypedInput)(nil)).Elem(),
	reflect.TypeOf((*bc.SpendInput)(nil)).Elem(),
	reflect.TypeOf((*bc.IssuanceInput)(nil)).Elem(),
	reflect.TypeOf((*bc.IssuanceWitness)(nil)).Elem(),
	reflect.TypeOf((*bc.TxInput)(nil)).Elem(),
	reflect.TypeOf((*bc.TxOutput)(nil)).Elem(),
	reflect.TypeOf((*bc.OutputCommitment)(nil)).Elem(),
	reflect.TypeOf((*bc.Outpoint)(nil)).Elem(),
	reflect.TypeOf((*bc.AssetAmount)(nil)).Elem(),
	// reflect.TypeOf((*foo)(nil)).Elem(),
	// reflect.TypeOf((*bar)(nil)).Elem(),
	// reflect.TypeOf((*baz)(nil)).Elem(),
}

const tagName = "bc"

func main() {
	fmt.Println("// AUTOMATICALLY GENERATED by gencodecs")
	fmt.Println("package bc")
	fmt.Println("")
	fmt.Println("import (")
	fmt.Println("\t\"io\"")
	fmt.Println("")
	fmt.Println("\t\"chain/encoding/blockchain\"")
	fmt.Println(")")
	for _, t := range types {
		if t.Kind() == reflect.Interface {
			continue
		}
		fmt.Printf("\n// type %s\n\n", t.Name())
		fmt.Printf("func (x *%s) Encode(w io.Writer, serflags uint8, writeFlags bool) (nbytes int, err error) {\n", t.Name())
		fmt.Println("\tvar nbytes2 int")
		fmt.Println("\tif writeFlags {")
		fmt.Println("\t\tnbytes2, err = w.Write([]byte{serflags})")
		fmt.Println("\t\tnbytes += nbytes2")
		fmt.Println("\t\tif err != nil {")
		fmt.Println("\t\t\treturn")
		fmt.Println("\t\t}")
		fmt.Println("\t}")
		writeEncoderItem(t, 0, "x", false)
		fmt.Println("\treturn")
		fmt.Println("}")

		fmt.Printf("\nfunc (x *%s) Decode(r io.Reader, serflags uint8, readFlags bool) (nbytes int, err error) {\n", t.Name())
		fmt.Println("\tvar nbytes2 int")
		fmt.Println("\tif readFlags {")
		fmt.Println("\t\tvar b [1]byte")
		fmt.Println("\t\tnbytes2, err = io.ReadFull(r, b[:])")
		fmt.Println("\t\tnbytes += nbytes2")
		fmt.Println("\t\tif err != nil {")
		fmt.Println("\t\t\treturn")
		fmt.Println("\t\t}")
		fmt.Println("\t\tserflags = b[0]")
		fmt.Println("\t}")
		readEncoderItem(t, 0, "x", false)
		fmt.Println("\treturn")
		fmt.Println("}")
	}
}

func panicf(f string, args ...interface{}) {
	panic(fmt.Sprintf(f, args...))
}

func isEncodableType(t reflect.Type) bool {
	for _, tt := range types {
		if t == tt {
			return true
		}
	}
	return false
}

func writeEncoderItem(t reflect.Type, depth int, name string, inExtstr bool) {
	indent := strings.Repeat("\t", 1+depth)
	nbytes2 := "nbytes2"
	if inExtstr {
		indent += "\t"
		nbytes2 = "_"
	}

	updateNbytesCheckErr := func() {
		if !inExtstr {
			fmt.Printf("%snbytes += nbytes2\n", indent)
		}
		fmt.Printf("%sif err != nil {\n", indent)
		fmt.Printf("%s\treturn\n", indent)
		fmt.Printf("%s}\n", indent)
	}

	if depth > 0 && isEncodableType(t) {
		fmt.Printf("%s%s, err = %s.Encode(w, serflags, false)\n", indent, nbytes2, name)
		updateNbytesCheckErr()
		return
	}

	switch t.Kind() {
	case reflect.Ptr:
		// xxx is this right?
		writeEncoderItem(t.Elem(), depth, name, inExtstr)

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		fmt.Printf("%s%s, err = blockchain.WriteVarint63(w, %s)\n", indent, nbytes2, name)
		updateNbytesCheckErr()

	case reflect.Array:
		if t.Elem().Kind() != reflect.Uint8 {
			panicf("cannot handle array of %s", t.Elem().Name())
		}
		fmt.Printf("%s%s, err = w.Write(%s[:])\n", indent, nbytes2, name)
		updateNbytesCheckErr()

	case reflect.Slice:
		t2 := t.Elem()
		if t2.Kind() == reflect.Slice && t2.Elem().Kind() == reflect.Uint8 {
			fmt.Printf("%s%s, err = blockchain.WriteVarstrList(w, %s)\n", indent, nbytes2, name)
			updateNbytesCheckErr()
		} else if t2.Kind() == reflect.Uint8 {
			fmt.Printf("%s%s, err = blockchain.WriteVarstr31(w, %s)\n", indent, nbytes2, name)
			updateNbytesCheckErr()
		} else {
			name2 := fmt.Sprintf("x%d", 2+depth)
			fmt.Printf("%s%s, err = blockchain.WriteVarint31(w, uint64(len(%s)))\n", indent, nbytes2, name)
			updateNbytesCheckErr()
			fmt.Printf("%sfor _, %s := range %s {\n", indent, name2, name)
			writeEncoderItem(t2, 1+depth, name2, inExtstr)
			fmt.Printf("%s}\n", indent)
		}

	case reflect.Struct:
		var extstr int

		endExtstr := func() {
			fmt.Printf("%s\treturn nil\n", indent)
			fmt.Printf("%s})\n", indent)
			updateNbytesCheckErr()
			extstr = 0
		}

		for i := 0; i < t.NumField(); i++ {
			tf := t.Field(i)
			if tag, ok := tf.Tag.Lookup(tagName); ok {
				ptag, err := parseTag(tag)
				if err != nil {
					panicf(fmt.Sprintf("parsing tag %s in type %s, field %s: %s", tag, t.Name(), tf.Name, err))
				}
				if ptag.omit {
					continue
				}
				switch ptag.extstr {
				case 0:
					if extstr > 0 {
						// In an extensible string that must now end.
						endExtstr()
					}
				case extstr:
					// Continue in the present extensible string.
				default:
					// Start a new extensible string.
					if extstr > 0 {
						// ...but first end the present one.
						endExtstr()
					}
					fmt.Printf("%s%s, err = blockchain.WriteExtensibleString(w, func(w io.Writer) (err error) {\n", indent, nbytes2)
					extstr = ptag.extstr
				}
			}
			writeEncoderItem(tf.Type, depth, fmt.Sprintf("%s.%s", name, tf.Name), extstr > 0)
		}

		if extstr > 0 {
			endExtstr()
		}

	default:
		if isEncodableType(t) {
			fmt.Printf("%s%s, err = %s.Encode(w, serflags, false)\n", indent, nbytes2, name)
			updateNbytesCheckErr()
		} else {
			panicf("cannot handle type %s", t.Name())
		}
	}
}

type parsedTag struct {
	int31, omit      bool
	extstr, serflags int
}

func parseTag(tag string) (result parsedTag, err error) {
	const (
		extstrPrefix   = "extstr="
		serflagsPrefix = "serflags="
	)

	items := strings.Split(tag, ",")
	for _, item := range items {
		if item == "varint31" {
			result.int31 = true
		} else if item == "omit" {
			result.omit = true
		} else if strings.HasPrefix(item, extstrPrefix) {
			suffix := strings.TrimPrefix(item, extstrPrefix)
			val, err := strconv.Atoi(suffix)
			if err != nil {
				return result, err
			}
			result.extstr = val
		} else if strings.HasPrefix(item, serflagsPrefix) {
			suffix := strings.TrimPrefix(item, serflagsPrefix)
			val, err := strconv.Atoi(suffix)
			if err != nil {
				return result, err
			}
			result.serflags = val
		}
	}
	return result, nil
}

func readEncoderItem(t reflect.Type, depth int, name string, inExtstr bool) {
	indent := strings.Repeat("\t", 1+depth)
	nbytes2 := "nbytes2"
	if inExtstr {
		indent += "\t"
		nbytes2 = "_"
	}

	var deref string
	if !strings.Contains(name, ".") {
		deref = "*"
	}

	updateNbytesCheckErr := func() {
		if !inExtstr {
			fmt.Printf("%snbytes += nbytes2\n", indent)
		}
		fmt.Printf("%sif err != nil {\n", indent)
		fmt.Printf("%s\treturn\n", indent)
		fmt.Printf("%s}\n", indent)
	}

	if depth > 0 && isEncodableType(t) {
		fmt.Printf("%s%s, err = %s.Decode(r, serflags, false)\n", indent, nbytes2, name)
		updateNbytesCheckErr()
		return
	}

	switch t.Kind() {
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		fmt.Printf("%s%s%s, %s, err = blockchain.ReadVarint63(r)\n", indent, deref, name, nbytes2)
		updateNbytesCheckErr()

	case reflect.Array:
		if t.Elem().Kind() != reflect.Uint8 {
			panicf("cannot handle array of %s", t.Elem().Name())
		}
		fmt.Printf("%s%s, err = io.ReadFull(r, (%s%s)[:])\n", indent, nbytes2, deref, name)
		updateNbytesCheckErr()

	case reflect.Slice:
		t2 := t.Elem()
		if t2.Kind() == reflect.Slice && t2.Elem().Kind() == reflect.Uint8 {
			fmt.Printf("%s%s%s, %s, err = blockchain.ReadVarstrList(r)\n", indent, deref, name, nbytes2)
			updateNbytesCheckErr()
		} else if t2.Kind() == reflect.Uint8 {
			fmt.Printf("%s%s%s, %s, err = blockchain.ReadVarstr31(r)\n", indent, deref, name, nbytes2)
			updateNbytesCheckErr()
		} else {
			var countName, iName string
			if depth == 0 {
				countName = "count"
				iName = "i"
			} else {
				countName = fmt.Sprintf("count%d", 1+depth)
				iName = fmt.Sprintf("i%d", 1+depth)
			}
			fmt.Printf("%s%s, %s, err = blockchain.ReadVarint31(r)\n", indent, countName, nbytes2)
			updateNbytesCheckErr()

			isPtr := t2.Kind() == reflect.Ptr
			var typeStr, deref2 string
			if isPtr {
				t2 = t2.Elem()
				typeStr = "*" + t2.Name()
				deref2 = ""
			} else {
				typeStr = t2.Name()
				deref2 = "*"
			}
			name2 := fmt.Sprintf("x%d", 2+depth)

			fmt.Printf("%s%s%s = make([]%s, 0, %s)\n", indent, deref, name, typeStr, countName)
			fmt.Printf("%sfor %s := uint32(0); %s < %s; %s++ {\n", indent, iName, iName, countName, iName)
			fmt.Printf("%s\t%s := new(%s)\n", indent, name2, t2.Name())
			readEncoderItem(t2, 1+depth, name2, inExtstr)
			fmt.Printf("%s\t%s%s = append(%s%s, %s%s)\n", indent, deref, name, deref, name, deref2, name2)
			fmt.Printf("%s}\n", indent)
		}

	case reflect.Struct:
		var extstr int

		endExtstr := func() {
			fmt.Printf("%s\treturn nil\n", indent)
			fmt.Printf("%s})\n", indent)
			updateNbytesCheckErr()
			extstr = 0
		}

		for i := 0; i < t.NumField(); i++ {
			tf := t.Field(i)
			if tag, ok := tf.Tag.Lookup(tagName); ok {
				ptag, err := parseTag(tag)
				if err != nil {
					panicf(fmt.Sprintf("parsing tag %s in type %s, field %s: %s", tag, t.Name(), tf.Name, err))
				}
				if ptag.omit {
					continue
				}
				switch ptag.extstr {
				case 0:
					if extstr > 0 {
						// In an extensible string that must now end.
						endExtstr()
					}
				case extstr:
					// Continue in the present extensible string.
				default:
					// Start a new extensible string.
					if extstr > 0 {
						// ...but first end the present one.
						endExtstr()
					}
					// xxx the "all" flag to ReadExtensibleString is slated for demolition
					fmt.Printf("%s%s, err = blockchain.ReadExtensibleString(r, true, func(r io.Reader) (err error) {\n", indent, nbytes2)
					extstr = ptag.extstr
				}
			}
			readEncoderItem(tf.Type, depth, fmt.Sprintf("%s.%s", name, tf.Name), extstr > 0)
		}

		if extstr > 0 {
			endExtstr()
		}

	default:
		panicf("cannot handle type %s", t.Name())
	}
}

func baseType(t reflect.Type) reflect.Type {
	switch t.Kind() {
	case reflect.Array, reflect.Ptr, reflect.Slice:
		return t.Elem()
	}
	return t
}
